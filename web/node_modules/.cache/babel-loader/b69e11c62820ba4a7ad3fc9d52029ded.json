{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\Hyejin Kim\\\\Documents\\\\Programming\\\\Chatapp\\\\\\uC138\\uBC88\\uC9F8- \\uB9AC\\uC561\\uD2B8,CSS\\\\my-chat-app-3\\\\web\\\\src\\\\components\\\\QuillEditor.js\",\n    _s = $RefreshSig$();\n\nimport React, { useMemo, useCallback, memo } from 'react'; // import styles from './quillEditor.module.css';\n\nimport ReactQuill from 'react-quill';\nimport 'react-quill/dist/quill.snow.css'; // react-quill과 css파일 import 하기\n\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nimport { Fragment as _Fragment } from \"react/jsx-dev-runtime\";\n\nconst QuillEditor = /*#__PURE__*/_s( /*#__PURE__*/memo(_c = _s(_ref => {\n  _s();\n\n  let {\n    quillRef,\n    api,\n    htmlContent,\n    setHtmlContent\n  } = _ref;\n  // 툴바의 사진 아이콘 클릭시 기존에 작동하던 방식 대신에 실행시킬 핸들러를 만들어주자.\n  const imageHandler = useCallback(() => {\n    const formData = new FormData(); // 이미지를 url로 바꾸기위해 서버로 전달할 폼데이터 만들기\n\n    const input = document.createElement('input'); // input 태그를 동적으로 생성하기\n\n    input.setAttribute('type', 'file');\n    input.setAttribute('accept', 'image/*'); // 이미지 파일만 선택가능하도록 제한\n\n    input.setAttribute('name', 'image');\n    input.click(); // 파일 선택창에서 이미지를 선택하면 실행될 콜백 함수 등록\n\n    input.onchange = async () => {\n      var _quill$getSelection;\n\n      const file = input.files[0];\n      formData.append('image', file); // 위에서 만든 폼데이터에 이미지 추가\n      // 폼데이터를 서버에 넘겨 multer로 이미지 URL 받아오기\n\n      const res = await api.uploadImage(formData);\n\n      if (!res.success) {\n        alert('이미지 업로드에 실패하였습니다.');\n      }\n\n      const url = res.payload.url;\n      const quill = quillRef.current.getEditor();\n      /* ReactQuill 노드에 대한 Ref가 있어야 메서드들을 호출할 수 있으므로\r\n            useRef()로 ReactQuill에 ref를 걸어주자.\r\n            getEditor() : 편집기를 지원하는 Quill 인스턴스를 반환함\r\n            여기서 만든 인스턴스로 getText()와 같은 메서드를 사용할 수 있다.*/\n\n      const range = (_quill$getSelection = quill.getSelection()) === null || _quill$getSelection === void 0 ? void 0 : _quill$getSelection.index; //getSelection()은 현재 선택된 범위를 리턴한다. 에디터가 포커싱되지 않았다면 null을 반환한다.\n\n      if (typeof range !== 'number') return;\n      /*range는 0이 될 수도 있으므로 null만 생각하고 !range로 체크하면 잘못 작동할 수 있다.\r\n            따라서 타입이 숫자이지 않을 경우를 체크해 리턴해주었다.*/\n\n      quill.setSelection(range, 1);\n      /* 사용자 선택을 지정된 범위로 설정하여 에디터에 포커싱할 수 있다. \r\n               위치 인덱스와 길이를 넣어주면 된다.*/\n\n      quill.clipboard.dangerouslyPasteHTML(range, `<img src=${url} alt=\"image\" />`);\n    }; //주어진 인덱스에 HTML로 작성된 내용물을 에디터에 삽입한다.\n\n  }, [api, quillRef]);\n  const modules = useMemo(() => ({\n    toolbar: {\n      // 툴바에 넣을 기능들을 순서대로 나열하면 된다.\n      container: [['bold', 'italic', 'underline', 'strike', 'blockquote'], [{\n        size: ['small', false, 'large', 'huge']\n      }, {\n        color: []\n      }], [{\n        list: 'ordered'\n      }, {\n        list: 'bullet'\n      }, {\n        indent: '-1'\n      }, {\n        indent: '+1'\n      }, {\n        align: []\n      }], ['image', 'video']],\n      handlers: {\n        // 위에서 만든 이미지 핸들러 사용하도록 설정\n        image: imageHandler\n      }\n    }\n  }), [imageHandler]);\n  return /*#__PURE__*/_jsxDEV(_Fragment, {\n    children: /*#__PURE__*/_jsxDEV(ReactQuill, {\n      ref: quillRef,\n      value: htmlContent,\n      onChange: setHtmlContent,\n      modules: modules,\n      theme: \"snow\" // className={styles.quillEditor}\n\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 78,\n      columnNumber: 7\n    }, this)\n  }, void 0, false);\n}, \"eMKI96N8OUPgkAiy7wCrfkiEX30=\")), \"eMKI96N8OUPgkAiy7wCrfkiEX30=\");\n\n_c2 = QuillEditor;\nexport default QuillEditor;\n\nvar _c, _c2;\n\n$RefreshReg$(_c, \"QuillEditor$memo\");\n$RefreshReg$(_c2, \"QuillEditor\");","map":{"version":3,"names":["React","useMemo","useCallback","memo","ReactQuill","QuillEditor","quillRef","api","htmlContent","setHtmlContent","imageHandler","formData","FormData","input","document","createElement","setAttribute","click","onchange","file","files","append","res","uploadImage","success","alert","url","payload","quill","current","getEditor","range","getSelection","index","setSelection","clipboard","dangerouslyPasteHTML","modules","toolbar","container","size","color","list","indent","align","handlers","image"],"sources":["C:/Users/Hyejin Kim/Documents/Programming/Chatapp/세번째- 리액트,CSS/my-chat-app-3/web/src/components/QuillEditor.js"],"sourcesContent":["import React, { useMemo, useCallback, memo } from 'react';\r\n// import styles from './quillEditor.module.css';\r\nimport ReactQuill from 'react-quill';\r\nimport 'react-quill/dist/quill.snow.css'; // react-quill과 css파일 import 하기\r\n\r\nconst QuillEditor = memo(({ quillRef, api, htmlContent, setHtmlContent }) => {\r\n  // 툴바의 사진 아이콘 클릭시 기존에 작동하던 방식 대신에 실행시킬 핸들러를 만들어주자.\r\n  const imageHandler = useCallback(() => {\r\n    const formData = new FormData(); // 이미지를 url로 바꾸기위해 서버로 전달할 폼데이터 만들기\r\n\r\n    const input = document.createElement('input'); // input 태그를 동적으로 생성하기\r\n    input.setAttribute('type', 'file');\r\n    input.setAttribute('accept', 'image/*'); // 이미지 파일만 선택가능하도록 제한\r\n    input.setAttribute('name', 'image');\r\n    input.click();\r\n\r\n    // 파일 선택창에서 이미지를 선택하면 실행될 콜백 함수 등록\r\n    input.onchange = async () => {\r\n      const file = input.files[0];\r\n      formData.append('image', file); // 위에서 만든 폼데이터에 이미지 추가\r\n\r\n      // 폼데이터를 서버에 넘겨 multer로 이미지 URL 받아오기\r\n      const res = await api.uploadImage(formData);\r\n      if (!res.success) {\r\n        alert('이미지 업로드에 실패하였습니다.');\r\n      }\r\n      const url = res.payload.url;\r\n      const quill = quillRef.current.getEditor();\r\n      /* ReactQuill 노드에 대한 Ref가 있어야 메서드들을 호출할 수 있으므로\r\n            useRef()로 ReactQuill에 ref를 걸어주자.\r\n            getEditor() : 편집기를 지원하는 Quill 인스턴스를 반환함\r\n            여기서 만든 인스턴스로 getText()와 같은 메서드를 사용할 수 있다.*/\r\n\r\n      const range = quill.getSelection()?.index;\r\n      //getSelection()은 현재 선택된 범위를 리턴한다. 에디터가 포커싱되지 않았다면 null을 반환한다.\r\n\r\n      if (typeof range !== 'number') return;\r\n      /*range는 0이 될 수도 있으므로 null만 생각하고 !range로 체크하면 잘못 작동할 수 있다.\r\n            따라서 타입이 숫자이지 않을 경우를 체크해 리턴해주었다.*/\r\n\r\n      quill.setSelection(range, 1);\r\n      /* 사용자 선택을 지정된 범위로 설정하여 에디터에 포커싱할 수 있다. \r\n               위치 인덱스와 길이를 넣어주면 된다.*/\r\n\r\n      quill.clipboard.dangerouslyPasteHTML(\r\n        range,\r\n        `<img src=${url} alt=\"image\" />`\r\n      );\r\n    }; //주어진 인덱스에 HTML로 작성된 내용물을 에디터에 삽입한다.\r\n  }, [api, quillRef]);\r\n\r\n  const modules = useMemo(\r\n    () => ({\r\n      toolbar: {\r\n        // 툴바에 넣을 기능들을 순서대로 나열하면 된다.\r\n        container: [\r\n          ['bold', 'italic', 'underline', 'strike', 'blockquote'],\r\n          [{ size: ['small', false, 'large', 'huge'] }, { color: [] }],\r\n          [\r\n            { list: 'ordered' },\r\n            { list: 'bullet' },\r\n            { indent: '-1' },\r\n            { indent: '+1' },\r\n            { align: [] },\r\n          ],\r\n          ['image', 'video'],\r\n        ],\r\n        handlers: {\r\n          // 위에서 만든 이미지 핸들러 사용하도록 설정\r\n          image: imageHandler,\r\n        },\r\n      },\r\n    }),\r\n    [imageHandler]\r\n  );\r\n  return (\r\n    <>\r\n      <ReactQuill\r\n        ref={quillRef}\r\n        value={htmlContent}\r\n        onChange={setHtmlContent}\r\n        modules={modules}\r\n        theme=\"snow\"\r\n        // className={styles.quillEditor}\r\n      />\r\n    </>\r\n  );\r\n});\r\n\r\nexport default QuillEditor;\r\n"],"mappings":";;;AAAA,OAAOA,KAAP,IAAgBC,OAAhB,EAAyBC,WAAzB,EAAsCC,IAAtC,QAAkD,OAAlD,C,CACA;;AACA,OAAOC,UAAP,MAAuB,aAAvB;AACA,OAAO,iCAAP,C,CAA0C;;;;;AAE1C,MAAMC,WAAW,iCAAGF,IAAI,SAAC,QAAoD;EAAA;;EAAA,IAAnD;IAAEG,QAAF;IAAYC,GAAZ;IAAiBC,WAAjB;IAA8BC;EAA9B,CAAmD;EAC3E;EACA,MAAMC,YAAY,GAAGR,WAAW,CAAC,MAAM;IACrC,MAAMS,QAAQ,GAAG,IAAIC,QAAJ,EAAjB,CADqC,CACJ;;IAEjC,MAAMC,KAAK,GAAGC,QAAQ,CAACC,aAAT,CAAuB,OAAvB,CAAd,CAHqC,CAGU;;IAC/CF,KAAK,CAACG,YAAN,CAAmB,MAAnB,EAA2B,MAA3B;IACAH,KAAK,CAACG,YAAN,CAAmB,QAAnB,EAA6B,SAA7B,EALqC,CAKI;;IACzCH,KAAK,CAACG,YAAN,CAAmB,MAAnB,EAA2B,OAA3B;IACAH,KAAK,CAACI,KAAN,GAPqC,CASrC;;IACAJ,KAAK,CAACK,QAAN,GAAiB,YAAY;MAAA;;MAC3B,MAAMC,IAAI,GAAGN,KAAK,CAACO,KAAN,CAAY,CAAZ,CAAb;MACAT,QAAQ,CAACU,MAAT,CAAgB,OAAhB,EAAyBF,IAAzB,EAF2B,CAEK;MAEhC;;MACA,MAAMG,GAAG,GAAG,MAAMf,GAAG,CAACgB,WAAJ,CAAgBZ,QAAhB,CAAlB;;MACA,IAAI,CAACW,GAAG,CAACE,OAAT,EAAkB;QAChBC,KAAK,CAAC,mBAAD,CAAL;MACD;;MACD,MAAMC,GAAG,GAAGJ,GAAG,CAACK,OAAJ,CAAYD,GAAxB;MACA,MAAME,KAAK,GAAGtB,QAAQ,CAACuB,OAAT,CAAiBC,SAAjB,EAAd;MACA;AACN;AACA;AACA;;MAEM,MAAMC,KAAK,0BAAGH,KAAK,CAACI,YAAN,EAAH,wDAAG,oBAAsBC,KAApC,CAhB2B,CAiB3B;;MAEA,IAAI,OAAOF,KAAP,KAAiB,QAArB,EAA+B;MAC/B;AACN;;MAEMH,KAAK,CAACM,YAAN,CAAmBH,KAAnB,EAA0B,CAA1B;MACA;AACN;;MAEMH,KAAK,CAACO,SAAN,CAAgBC,oBAAhB,CACEL,KADF,EAEG,YAAWL,GAAI,iBAFlB;IAID,CA/BD,CAVqC,CAyClC;;EACJ,CA1C+B,EA0C7B,CAACnB,GAAD,EAAMD,QAAN,CA1C6B,CAAhC;EA4CA,MAAM+B,OAAO,GAAGpC,OAAO,CACrB,OAAO;IACLqC,OAAO,EAAE;MACP;MACAC,SAAS,EAAE,CACT,CAAC,MAAD,EAAS,QAAT,EAAmB,WAAnB,EAAgC,QAAhC,EAA0C,YAA1C,CADS,EAET,CAAC;QAAEC,IAAI,EAAE,CAAC,OAAD,EAAU,KAAV,EAAiB,OAAjB,EAA0B,MAA1B;MAAR,CAAD,EAA8C;QAAEC,KAAK,EAAE;MAAT,CAA9C,CAFS,EAGT,CACE;QAAEC,IAAI,EAAE;MAAR,CADF,EAEE;QAAEA,IAAI,EAAE;MAAR,CAFF,EAGE;QAAEC,MAAM,EAAE;MAAV,CAHF,EAIE;QAAEA,MAAM,EAAE;MAAV,CAJF,EAKE;QAAEC,KAAK,EAAE;MAAT,CALF,CAHS,EAUT,CAAC,OAAD,EAAU,OAAV,CAVS,CAFJ;MAcPC,QAAQ,EAAE;QACR;QACAC,KAAK,EAAEpC;MAFC;IAdH;EADJ,CAAP,CADqB,EAsBrB,CAACA,YAAD,CAtBqB,CAAvB;EAwBA,oBACE;IAAA,uBACE,QAAC,UAAD;MACE,GAAG,EAAEJ,QADP;MAEE,KAAK,EAAEE,WAFT;MAGE,QAAQ,EAAEC,cAHZ;MAIE,OAAO,EAAE4B,OAJX;MAKE,KAAK,EAAC,MALR,CAME;;IANF;MAAA;MAAA;MAAA;IAAA;EADF,iBADF;AAYD,CAlFuB,kCAAP,iCAAjB;;MAAMhC,W;AAoFN,eAAeA,WAAf"},"metadata":{},"sourceType":"module"}